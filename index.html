<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI Coach - Analytical Layout</title>
    <style>
        /* --- GENERAL LAYOUT --- */
        body {
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 20px 0;
            margin: 0;
            background-color: #f0f0f0;
            user-select: none;
            font-family: sans-serif;
        }

        /* --- CONTROL PANEL --- */
        #control-panel {
            width: 800px; 
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #control-panel label {
            font-weight: bold;
            color: #333;
        }

        #control-panel select, #control-panel button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1em;
            cursor: pointer;
        }
        
        #reset-button {
            background-color: #f44336;
            color: white;
            border: none;
            font-weight: bold;
        }

        /* --- MAIN GAME CONTAINER: EXPLICIT GRID --- */
        #game-container {
            display: grid; 
            grid-template-columns: 480px 20px 30px 20px 260px;
            grid-template-rows: auto;
            align-items: start; 
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            width: 850px; 
            box-sizing: border-box; 
        }
        
        #chessboard { grid-column: 1; }
        #evaluation-bar-container { grid-column: 3; }
        #sidebar { grid-column: 5; }


        /* --- CHESS BOARD --- */
        .square-size {
            width: 60px; 
            height: 60px; 
        }
        
        #chessboard {
            width: 480px; 
            height: 480px; 
            display: grid;
            grid-template-columns: repeat(8, 60px); 
            grid-template-rows: repeat(8, 60px);
            border: 5px solid #333;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            background-color: #333;
            position: relative; 
        }

        .square {
            box-sizing: border-box; 
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; 
        }

        .light { background-color: #eed6b0; }
        .dark { background-color: #b58863; }
        
        .piece {
            width: 100%;
            height: 100%;
            background-size: 85%;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            z-index: 2; 
        }
        
        .moving-piece {
            transition: transform 0.3s ease-out;
            z-index: 1000; 
        }
        
        .dragging {
            width: 60px; 
            height: 60px; 
            transform: scale(1.15); 
        }

        /* --- EVALUATION BAR STYLES --- */
        #evaluation-bar-container {
            width: 30px; 
            height: 480px; 
            background-color: #000; 
            border-radius: 5px;
            overflow: hidden;
            position: relative; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        #evaluation-bar-fill {
            position: absolute;
            bottom: 0; 
            width: 100%;
            background-color: #fff; 
            transition: height 0.3s ease-out;
        }
        
        #evaluation-score {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            white-space: nowrap;
            font-weight: bold;
            font-size: 1.1em;
            color: #fff; 
            z-index: 5;
            transition: transform 0.3s ease-out;
        }
        
        /* --- SIDEBAR AND HISTORY --- */
        #sidebar {
            width: 260px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-box {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        #opening-display {
            font-size: 1.1em;
            font-weight: bold;
            color: #007bff;
        }

        #move-list-container {
            max-height: 400px; 
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
        }
        
        #move-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px 10px; 
        }

        #move-list li {
            font-size: 0.9em;
            padding: 2px 5px;
            border-radius: 3px;
            flex-basis: 45%; 
            display: flex;
            cursor: pointer; 
        }
        
        .move-number {
            font-weight: bold;
            color: #666;
            margin-right: 5px;
        }
        
        /* --- CLASSIFICATION STYLES --- */
        .move-classification {
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 5px;
            padding: 1px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .BestMove { background-color: #4CAF50; color: white; } 
        .GreatMove { background-color: #8BC34A; color: white; }
        .Good { background-color: #FFC107; color: black; } 
        .Inaccuracy { background-color: #FF9800; color: black; } 
        .Mistake { background-color: #FF5722; color: white; } 
        .Blunder { background-color: #F44336; color: white; } 
        .Book { background-color: #00BCD4; color: white; } 


        /* --- HIGHLIGHTS and Dragging --- */
        .selected { background-color: rgba(255, 255, 0, 0.5) !important; }
        .in-check { background-color: rgba(255, 0, 0, 0.6) !important; }

        .move-target::after {
            content: '';
            display: block;
            width: 18px; 
            height: 18px; 
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .square.move-target:not(:empty)::after { display: none; }
        .square.move-target .piece {
             box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.2); 
             border-radius: 50%;
        }

        /* --- DIALOGS --- */
        .piece-choice {
            width: 45px;
            height: 45px;
        }
        .overlay-dialog {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            z-index: 10000;
            display: none;
            text-align: center;
        }

        /* --- PIECE IMAGES (Requires 'images' folder in root) --- */
        .wk { background-image: url('images/wk.png'); }
        .wq { background-image: url('images/wq.png'); }
        .wr { background-image: url('images/wr.png'); }
        .wb { background-image: url('images/wb.png'); }
        .wn { background-image: url('images/wn.png'); }
        .wp { background-image: url('images/wp.png'); }
        .bk { background-image: url('images/bk.png'); }
        .bq { background-image: url('images/bq.png'); }
        .br { background-image: url('images/br.png'); }
        .bb { background-image: url('images/bb.png'); }
        .bn { background-image: url('images/bn.png'); }
        .bp { background-image: url('images/bp.png'); }

        .promo-Q { background-image: url('images/wq.png'); }
        .promo-R { background-image: url('images/wr.png'); }
        .promo-B { background-image: url('images/wb.png'); }
        .promo-N { background-image: url('images/wn.png'); }
    </style>
</head>
<body>

    <div id="control-panel">
        <div>
            <label for="color-selector">Play As:</label>
            <select id="color-selector" onchange="game.setPlayerColor(this.value)">
                <option value="w" selected>White</option>
                <option value="b">Black</option>
                <option value="r">Random</option>
            </select>
        </div>
        
        <div>
            <label for="elo-selector">AI ELO Rating:</label>
            <select id="elo-selector" onchange="game.setDifficulty(this.value)">
                <option value="250">250 (Beginner)</option>
                <option value="500">500 (Novice)</option>
                <option value="800">800 (Casual)</option>
                <option value="1100">1100 (Intermediate)</option>
                <option value="1400">1400 (Club Player)</option>
                <option value="1700">1700 (Expert)</option>
                <option value="2000">2000 (Master)</option>
                <option value="2200">2200 (Candidate Master)</option>
                <option value="2300">2300 (FIDE Master)</option>
                <option value="2400">2400 (International Master)</option>
                <option value="2500">2500 (Grandmaster)</option>
                <option value="2700" selected>2700 (Super GM - Default)</option>
            </select>
        </div>
        
        <button id="reset-button" onclick="game.restartGame()">ðŸ”¥ Reset Game</button>
    </div>
    
    <div id="promotion-dialog" class="overlay-dialog">
        <h3>Promote to:</h3>
        <div id="promotion-choices"></div>
    </div>
    
    <div id="game-over-dialog" class="overlay-dialog">
        <h3 id="game-over-message"></h3>
        <button onclick="game.restartGame()">Restart Game</button>
    </div>

    <div id="game-container">
        
        <div id="chessboard" class="square-size"></div>

        <div id="evaluation-bar-container">
            <div id="evaluation-bar-fill"></div>
            <div id="evaluation-score">0.00</div>
        </div>
        
        <div id="sidebar">
            
            <div class="info-box">
                <h4>Opening:</h4>
                <div id="opening-display">Initial Position</div>
            </div>

            <div class="info-box">
                <h4>Move History:</h4>
                <div id="move-list-container">
                    <ol id="move-list"></ol>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const ROWS = 8;
        const COLS = 8;
        const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'; 
        let AI_PLAYER = 'b'; 

        // --- MOVE CLASSIFICATION THRESHOLDS (Centipawns) ---
        const MOVE_THRESHOLDS = {
            BLUNDER: 300,       
            MISTAKE: 100,       
            INACCURACY: 50,     
            GREAT_MOVE: 10,     
            BEST_MOVE: 5,       
        };
        
        // --- Simplified Opening Database (for display only) ---
        const OPENING_DB = {
            'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1': 'Open Game (1. e4)',
            'rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq - 0 1': 'Closed Game (1. d4)',
            'r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 3': 'Ruy Lopez',
            'rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2': 'Sicilian Defense',
        };


        // --- STOCKFISH ELO MAPPING (Controls Skill and Depth) ---
        const ELO_MAP = {
            '250':  { skill: 0, depth: 1, movetime: 100, mistake: 0.95 },
            '500':  { skill: 3, depth: 2, movetime: 150, mistake: 0.8 },
            '800':  { skill: 6, depth: 3, movetime: 200, mistake: 0.6 },
            '1100': { skill: 9, depth: 5, movetime: 300, mistake: 0.4 },
            '1400': { skill: 12, depth: 8, movetime: 500, mistake: 0.2 },
            '1700': { skill: 15, depth: 10, movetime: 700, mistake: 0.05 },
            '2000': { skill: 18, depth: 12, movetime: 800, mistake: 0.0 },
            '2200': { skill: 18, depth: 13, movetime: 900, mistake: 0.0 }, 
            '2300': { skill: 19, depth: 14, movetime: 1000, mistake: 0.0 }, 
            '2400': { skill: 20, depth: 15, movetime: 1200, mistake: 0.0 }, 
            '2500': { skill: 18, depth: 15, movetime: 1500, mistake: 0.0 }, 
            '2700': { skill: 20, depth: 18, movetime: 2000, mistake: 0.0 } 
        };

        // --- DOM ELEMENTS ---
        const boardEl = document.getElementById('chessboard');
        const promoDialog = document.getElementById('promotion-dialog');
        const promoChoices = document.getElementById('promotion-choices');
        const gameOverDialog = document.getElementById('game-over-dialog');
        const gameOverMessage = document.getElementById('game-over-message');
        const eloSelector = document.getElementById('elo-selector');
        const colorSelector = document.getElementById('color-selector');
        const moveListEl = document.getElementById('move-list');
        const openingDisplayEl = document.getElementById('opening-display');
        
        // Evaluation Bar Elements
        const evalFillEl = document.getElementById('evaluation-bar-fill');
        const evalScoreEl = document.getElementById('evaluation-score');


        // --- STOCKFISH WORKER AND STATE ---
        let stockfish = null;
        let sfReady = false;
        const BEST_MOVES = []; 
        let currentAISettings = ELO_MAP['2700']; 
        
        let currentAnalysisMoveIndex = -1; 
        let analysisMultiPV = [];          
        let isAiMoveRequested = false;     
        let pendingLegalMovesRequest = null; 

        function initStockfish() {
            try {
                // IMPORTANT: This line requires stockfish.js in the same directory.
                stockfish = new Worker("stockfish.js"); 
                
                stockfish.onmessage = handleStockfishMessage;
                stockfish.onerror = (e) => {
                    console.error("Stockfish worker error:", e);
                    // Use a visual alert for the user if the worker fails to load.
                    alert("Stockfish AI failed to load. Ensure 'stockfish.js' is accessible via your web server (or in the same directory).");
                };

                stockfish.postMessage("uci");
                stockfish.postMessage("isready");

                console.log("Stockfish worker initiated.");
            } catch (e) {
                console.error("Failed to load stockfish.js:", e);
                alert("Stockfish AI failed to load. Ensure 'stockfish.js' is accessible via your web server.");
            }
        }

        function configureStockfish() {
            if (!stockfish || !sfReady) return;
            stockfish.postMessage(`setoption name Skill Level value ${currentAISettings.skill}`);
            stockfish.postMessage("setoption name MultiPV value 1"); 
            console.log(`Stockfish configured: Skill Level ${currentAISettings.skill}`);
        }

        function handleStockfishMessage(event) {
            const line = event.data;

            if (line === "readyok") {
                sfReady = true;
                configureStockfish();
                if (game.turn === AI_PLAYER) game.requestAIMove();
                game.requestLiveEvaluation(); 
            }
            
            // --- Legal Move List Response ---
            if (pendingLegalMovesRequest && line.startsWith("Legal moves:")) {
                const moves = line.substring(13).trim().split(/\s+/).filter(m => m.length > 0);
                const resolve = pendingLegalMovesRequest.resolve;
                const checkStatusLine = pendingLegalMovesRequest.checkStatusLine;
                
                pendingLegalMovesRequest = null;
                
                // Extract check status if available in the previous line of the 'd' command output
                const inCheck = checkStatusLine ? checkStatusLine.includes("Check: true") : false;

                resolve({ moves, inCheck });
                return; 
            }
            // Capture the line preceding the "Legal moves:" line, which often contains FEN and Check status
            if (pendingLegalMovesRequest && line.startsWith("Fen:")) {
                 pendingLegalMovesRequest.checkStatusLine = line;
                 return;
            }


            // --- Analysis Mode (MultiPV) ---
            if (currentAnalysisMoveIndex >= 0 && line.startsWith("info depth") && line.includes("multipv")) {
                const parts = line.split(' ');
                const scoreIndex = parts.indexOf("score");
                const pvIndex = parts.indexOf("pv");
                const multiPVIndex = parts.indexOf("multipv");

                if (scoreIndex !== -1 && pvIndex !== -1 && multiPVIndex !== -1) {
                    const scoreValue = parseInt(parts[scoreIndex + 2]);
                    const move = parts[pvIndex + 1];
                    const multipv = parseInt(parts[multiPVIndex + 1]);
                    
                    analysisMultiPV.push({ score: scoreValue, move: move, multipv: multipv });
                }
            } else if (currentAnalysisMoveIndex >= 0 && line.startsWith("bestmove")) {
                game.processAnalysisResult();
            }

            // --- AI Move Calculation / Live Eval (MultiPV 1) ---
            if (currentAnalysisMoveIndex < 0 && line.startsWith("info depth")) {
                const parts = line.split(' ');
                const scoreIndex = parts.indexOf("score");
                
                if (scoreIndex !== -1) {
                    const scoreValue = parseInt(parts[scoreIndex + 2]);
                    const scoreType = parts[scoreIndex + 1];

                    if(isAiMoveRequested) {
                        const moveIndex = parts.indexOf("pv");
                        if (moveIndex !== -1) {
                            const move = parts[moveIndex + 1];
                            if (!BEST_MOVES.some(m => m.move === move)) {
                                BEST_MOVES.push({ move: move, score: scoreValue, type: scoreType });
                                BEST_MOVES.sort((a, b) => b.score - a.score).splice(3); 
                            }
                        }
                    }
                    
                    if (scoreType === 'cp') {
                        game.updateEvaluationDisplay(scoreValue / 100, 'cp');
                    } else if (scoreType === 'mate') {
                        game.updateEvaluationDisplay(scoreValue, 'mate');
                    }
                }
            } else if (currentAnalysisMoveIndex < 0 && line.startsWith("bestmove")) {
                if (isAiMoveRequested && BEST_MOVES.length > 0) { 
                    game.processAIMove();
                }
                isAiMoveRequested = false;
                game.requestLiveEvaluation(); 
            }
        }
        
        // --- CHESS LOGIC UTILITIES ---
        
        const PIECE_MAP = {
            'K': { class: 'wk', type: 'King', color: 'w' }, 'Q': { class: 'wq', type: 'Queen', color: 'w' },
            'R': { class: 'wr', type: 'Rook', color: 'w' }, 'B': { class: 'wb', type: 'Bishop', color: 'w' },
            'N': { class: 'wn', type: 'Knight', color: 'w' }, 'P': { class: 'wp', type: 'Pawn', color: 'w' },
            'k': { class: 'bk', type: 'King', color: 'b' }, 'q': { class: 'bq', type: 'Queen', color: 'b' },
            'r': { class: 'br', type: 'Rook', color: 'b' }, 'b': { class: 'bb', type: 'Bishop', color: 'b' },
            'n': { class: 'bn', type: 'Knight', color: 'b' }, 'p': { class: 'bp', type: 'Pawn', color: 'b' },
            '': { class: '', type: 'Empty', color: '' }
        };

        function toCoords(notation) {
            const col = notation.charCodeAt(0) - 97;
            const row = 8 - parseInt(notation[1]);
            return { row, col };
        }
        function toNotation(row, col) {
            return String.fromCharCode(97 + col) + (8 - row);
        }
        
        class ChessGame {
            constructor() {
                document.addEventListener('mousemove', e => this.onMouseMove(e));
                document.addEventListener('mouseup', e => this.onMouseUp(e));
                
                this.setDifficulty(eloSelector.value);
                this.setPlayerColor(colorSelector.value); 
                
                // Initialize Stockfish immediately
                initStockfish();
            }
            
            setDifficulty(elo) {
                currentAISettings = ELO_MAP[elo];
                configureStockfish(); 
            }

            setPlayerColor(colorCode) {
                this.userSelectedColor = colorCode;
                
                if (colorCode === 'r') {
                    const randomColor = Math.random() < 0.5 ? 'w' : 'b';
                    AI_PLAYER = randomColor === 'w' ? 'b' : 'w';
                } else {
                    AI_PLAYER = colorCode === 'w' ? 'b' : 'w';
                }
                
                if (this.board) this.initBoard(); 
            }

            initBoard() {
                this.board = Array(ROWS).fill(null).map(() => Array(COLS).fill('')); 
                this.turn = 'w';
                this.castling = { wK: true, wQ: true, bK: true, bQ: true };
                this.enPassant = null;
                this.selected = null; 
                this.pendingPromo = null;
                this.inCheck = false;
                this.dragOrigin = null;
                this.dragGhost = null;
                this.isDragging = false;
                this.isAnimating = false;
                this.isGameOver = false;
                this.moveHistory = []; 
                this.fenHistory = [START_FEN]; 
                this.lastMove = null; 
                this.analysisScores = []; 
                currentAnalysisMoveIndex = -1; 
                analysisMultiPV = [];

                this.loadFEN(START_FEN);
                gameOverDialog.style.display = 'none';
                this.updateMoveListDisplay();
                this.updateOpeningDisplay();
                this.render(); 

                if (sfReady) {
                    if (this.turn === AI_PLAYER) this.requestAIMove();
                    this.requestLiveEvaluation();
                }
            }

            restartGame() {
                this.initBoard();
                this.render();
            }

            // --- FEN/Board Management ---
            getFEN(boardState, currentTurn, castlingState, enPassantSquare) {
                let fen = "";
                for (let r = 0; r < 8; r++) {
                    let emptyCount = 0;
                    for (let c = 0; c < 8; c++) {
                        const piece = boardState[r][c];
                        if (piece) {
                            if (emptyCount > 0) { fen += emptyCount; emptyCount = 0; }
                            fen += piece;
                        } else {
                            emptyCount++;
                        }
                    }
                    if (emptyCount > 0) fen += emptyCount;
                    if (r < 7) fen += "/";
                }
                
                const turnToUse = currentTurn || this.turn;
                
                const halfMoveClock = 0; 
                const fullMoveNumber = Math.floor(this.moveHistory.length / 2) + 1;

                let castlingStr = "";
                const cs = castlingState || this.castling;
                if (cs.wK) castlingStr += "K";
                if (cs.wQ) castlingStr += "Q";
                if (cs.bK) castlingStr += "k";
                if (cs.bQ) castlingStr += "q";
                castlingStr = castlingStr || '-';
                
                const ep = enPassantSquare || this.enPassant || '-';

                return `${fen} ${turnToUse} ${castlingStr} ${ep} ${halfMoveClock} ${fullMoveNumber}`;
            }

            loadFEN(fen) {
                const parts = fen.split(' ');
                let r = 0, c = 0;
                for (const char of parts[0]) {
                    if (char === '/') { r++; c = 0; } 
                    else if (/\d/.test(char)) { c += parseInt(char); } 
                    else { this.board[r][c] = char; c++; }
                }
                this.turn = parts[1];
            }

            // --- History and Analysis Updates ---
            recordMove(uciMove) {
                this.moveHistory.push(uciMove);
                this.fenHistory.push(this.getFEN(this.board, this.turn, this.castling, this.enPassant)); 
                
                this.analyzeNextMove();
                
                this.updateMoveListDisplay();
                this.updateOpeningDisplay();
                this.requestLiveEvaluation();
            }

            updateMoveListDisplay() {
                moveListEl.innerHTML = '';
                let whiteMove = null;
                let moveNumber = 1;

                for (let i = 0; i < this.moveHistory.length; i++) {
                    const uci = this.moveHistory[i];
                    const analysis = this.analysisScores.find(a => a.moveIndex === i);
                    const classification = (i < 4 && !analysis) ? 'Book' : (analysis ? analysis.classification : '...');
                    const classificationHTML = classification !== '...' 
                        ? `<span class="move-classification ${classification.replace(' ', '')}">${classification}</span>`
                        : '...';

                    if (i % 2 === 0) { 
                        whiteMove = uci;
                        if (i === this.moveHistory.length - 1) {
                             let li = document.createElement('li');
                             li.innerHTML = `<span class="move-number">${moveNumber}.</span> ${whiteMove} ${classificationHTML}`; 
                             moveListEl.appendChild(li);
                        }
                    } else { 
                        let li = document.createElement('li');
                        const whiteAnalysis = this.analysisScores.find(a => a.moveIndex === i - 1);
                        const whiteClassification = (i - 1 < 4 && !whiteAnalysis) ? 'Book' : (whiteAnalysis ? whiteAnalysis.classification : '...');
                        const whiteClassificationHTML = whiteClassification !== '...'
                            ? `<span class="move-classification ${whiteClassification.replace(' ', '')}">${whiteClassification}</span>`
                            : '...';
                            
                        li.innerHTML = `<span class="move-number">${moveNumber}.</span> ${this.moveHistory[i-1]} ${whiteClassificationHTML} ${uci} ${classificationHTML}`;
                        moveListEl.appendChild(li);
                        whiteMove = null; 
                        moveNumber++;
                    }
                }
                
                moveListEl.parentElement.scrollTop = moveListEl.parentElement.scrollHeight;
            }

            // --- Move Classification Logic ---
            analyzeNextMove() {
                if (!sfReady) return;

                const nextIndex = this.analysisScores.length;

                if (nextIndex >= this.moveHistory.length) {
                    currentAnalysisMoveIndex = -1; 
                    return;
                }
                
                const FEN_before = this.fenHistory[nextIndex]; 
                
                currentAnalysisMoveIndex = nextIndex;
                analysisMultiPV.length = 0; 

                stockfish.postMessage("stop");
                stockfish.postMessage("setoption name MultiPV value 3"); 
                stockfish.postMessage(`position fen ${FEN_before}`);
                stockfish.postMessage("go depth 15"); 
            }
            
            processAnalysisResult() {
                stockfish.postMessage("setoption name MultiPV value 1"); 
                
                const movePlayedUCI = this.moveHistory[currentAnalysisMoveIndex];
                
                if (analysisMultiPV.length === 0) {
                     this.analysisScores.push({ moveIndex: currentAnalysisMoveIndex, classification: 'Book', scoreDrop: 0 });
                     this.analyzeNextMove();
                     return;
                }
                
                analysisMultiPV.sort((a, b) => b.score - a.score);
                
                const bestScoreCP = analysisMultiPV[0].score;
                const actualMoveData = analysisMultiPV.find(a => a.move === movePlayedUCI);
                
                const actualScoreCP = actualMoveData ? actualMoveData.score : bestScoreCP - MOVE_THRESHOLDS.BLUNDER; 

                const scoreDrop = bestScoreCP - actualScoreCP; 
                const classification = this.classifyMove(scoreDrop);

                this.analysisScores.push({
                    moveIndex: currentAnalysisMoveIndex,
                    classification: classification,
                    scoreDrop: scoreDrop / 100 
                });
                
                this.updateMoveListDisplay();
                
                this.analyzeNextMove();
            }

            classifyMove(scoreDrop) {
                if (scoreDrop <= MOVE_THRESHOLDS.BEST_MOVE) return 'Best Move';
                if (scoreDrop <= MOVE_THRESHOLDS.GREAT_MOVE) return 'Great Move';
                if (scoreDrop <= MOVE_THRESHOLDS.INACCURACY) return 'Good';
                if (scoreDrop <= MOVE_THRESHOLDS.MISTAKE) return 'Inaccuracy';
                if (scoreDrop <= MOVE_THRESHOLDS.BLUNDER) return 'Mistake';
                return 'Blunder';
            }

            // --- Core Game Methods ---

            render() {
                if (this.isAnimating) return; 

                document.querySelectorAll('.move-target').forEach(el => el.classList.remove('move-target'));
                boardEl.innerHTML = '';
                const enableInput = this.turn !== AI_PLAYER && !this.isGameOver;
                const squareSizeClass = 'square-size'; 

                const flip = this.userSelectedColor === 'b'; 

                for (let i = 0; i < 64; i++) {
                    let r, c;
                    
                    if (flip) {
                        r = Math.floor(i / 8);
                        c = i % 8;
                    } else {
                        r = 7 - Math.floor(i / 8);
                        c = i % 8;
                    }
                    
                    const notation = toNotation(r, c);
                    const sq = document.createElement('div');
                    sq.id = notation;
                    sq.className = `square ${squareSizeClass} ${(r + c) % 2 ? 'dark' : 'light'}`;
                    
                    if (enableInput) {
                        sq.addEventListener('mousedown', e => this.onMouseDown(e, notation));
                    }

                    const pCode = this.board[r][c];
                    if (pCode) {
                        const pDiv = document.createElement('div');
                        pDiv.className = `piece ${PIECE_MAP[pCode].class}`;
                        sq.appendChild(pDiv);
                    }
                    
                    if (this.selected === notation) sq.classList.add('selected');
                    
                    if (this.inCheck && pCode && PIECE_MAP[pCode].type === 'King' && PIECE_MAP[pCode].color === this.turn) {
                        sq.classList.add('in-check');
                    }

                    boardEl.appendChild(sq);
                }
            }
            
            async updateHighlights() {
                document.querySelectorAll('.move-target').forEach(el => el.classList.remove('move-target'));
                if (!sfReady) return;

                if (this.selected) {
                    const { moves } = await this.getLegalMoves(this.selected);
                    moves.forEach(m => {
                        document.getElementById(m.substring(2, 4))?.classList.add('move-target');
                    });
                }
            }

            updateEvaluationDisplay(score, type) {
                if (!sfReady) return;
                
                let percent;
                let scoreText;
                const perspective = this.userSelectedColor === 'w' ? 1 : -1;
                const scoreInUserPerspective = score * perspective;

                if (type === 'mate') {
                    percent = scoreInUserPerspective > 0 ? 100 : 0;
                    scoreText = `M${Math.abs(score)}`;
                } else {
                    const cappedScore = scoreInUserPerspective;
                    const maxCp = 1000;
                    const normalizedScore = 500 + Math.min(Math.max(cappedScore, -maxCp), maxCp) / 2;
                    
                    percent = normalizedScore / 10;
                    
                    const actualScore = score;
                    const sign = actualScore > 0 ? '+' : '';
                    scoreText = `${sign}${actualScore.toFixed(2)}`;
                }

                evalFillEl.style.height = `${percent}%`;
                evalScoreEl.textContent = scoreText;
                
                if (percent < 40) {
                    evalScoreEl.style.color = '#fff'; 
                    evalFillEl.style.backgroundColor = '#000';
                } else if (percent > 60) {
                    evalScoreEl.style.color = '#000'; 
                    evalFillEl.style.backgroundColor = '#fff';
                } else {
                    evalScoreEl.style.color = '#333'; 
                    evalFillEl.style.backgroundColor = '#fff';
                }
            }

            requestLiveEvaluation() {
                if (this.isAnimating || !sfReady || this.isGameOver || currentAnalysisMoveIndex >= 0) return;
                
                stockfish.postMessage("stop");
                const currentFEN = this.getFEN(this.board, this.turn, this.castling, this.enPassant);
                
                stockfish.postMessage(`position fen ${currentFEN}`);
                stockfish.postMessage("go depth 18"); 
            }

            requestAIMove() {
                if (this.isGameOver || this.turn !== AI_PLAYER || !sfReady || this.isAnimating || currentAnalysisMoveIndex >= 0) return;
                
                isAiMoveRequested = true;
                stockfish.postMessage("stop"); 
                BEST_MOVES.length = 0;

                const currentFEN = this.getFEN(this.board, this.turn, this.castling, this.enPassant);
                stockfish.postMessage(`position fen ${currentFEN}`);
                
                stockfish.postMessage(`go movetime ${currentAISettings.movetime}`); 
            }

            processAIMove() {
                isAiMoveRequested = false;

                if (BEST_MOVES.length === 0) {
                    this.checkGameOver(); 
                    return;
                }

                BEST_MOVES.sort((a, b) => b.score - a.score);

                let moveUCI;
                
                if (Math.random() < currentAISettings.mistake) {
                    const mistakeIndex = Math.floor(Math.random() * (BEST_MOVES.length > 1 ? BEST_MOVES.length : 1));
                    moveUCI = BEST_MOVES[mistakeIndex].move;
                } else {
                    moveUCI = BEST_MOVES[0].move;
                }
                
                const from = moveUCI.substring(0, 2);
                const to = moveUCI.substring(2, 4);
                const promotion = moveUCI.length === 5 ? moveUCI.substring(4, 5) : null;
                
                if (promotion) {
                    const promoType = promotion.toUpperCase();
                    this.pendingPromo = { from, to, type: promoType };
                }

                this.tryMove(from, to, true, moveUCI);
            }
            
            async animateMove(from, to) {
                const fromEl = document.getElementById(from);
                const toEl = document.getElementById(to);
                const pieceEl = fromEl ? fromEl.querySelector('.piece') : null;
                
                if (!pieceEl) return;
                
                this.isAnimating = true;
                const targetPiece = toEl.querySelector('.piece');
                if (targetPiece) targetPiece.style.visibility = 'hidden';
                
                pieceEl.classList.add('moving-piece');
                
                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();

                const dx = toRect.left - fromRect.left;
                const dy = toRect.top - fromRect.top;

                pieceEl.style.transform = `translate(${dx}px, ${dy}px)`;

                return new Promise(resolve => {
                    setTimeout(() => {
                        if (targetPiece) targetPiece.style.visibility = 'visible';
                        this.isAnimating = false;
                        pieceEl.classList.remove('moving-piece');
                        pieceEl.style.transform = '';
                        resolve();
                    }, 300); 
                });
            }

            async tryMove(from, to, isAiMove = false, uciMoveOverride = null) {
                if (this.isGameOver || this.isAnimating || !sfReady) return false;
                
                let uciMove = uciMoveOverride || (from + to); 
                
                const { moves: legalMoves } = await this.getLegalMoves(from);
                const isLegal = legalMoves.some(m => m.startsWith(from + to));

                if (isLegal) {
                    this.isAnimating = true;
                    this.selected = null; 
                    
                    if (this.isPawnPromotion(from, to)) {
                        if (isAiMove) {
                            // AI move already contains the promotion piece in uciMoveOverride
                        } else if (!this.pendingPromo) {
                            this.pendingPromo = { from, to, uci: uciMove };
                            await this.animateMove(from, to); 
                            this.showPromo();
                            this.isAnimating = false; 
                            return true; 
                        }
                    }

                    await this.animateMove(from, to);
                    
                    this.executeMove(from, to);
                    this.isAnimating = false;
                    
                    const finalUci = this.pendingPromo && this.pendingPromo.type
                        ? uciMove + this.pendingPromo.type.toLowerCase()
                        : uciMove;

                    if (!this.isPawnPromotion(from, to) || isAiMove || this.pendingPromo === null) {
                         this.recordMove(finalUci);
                    }

                    this.render();

                    if (this.isGameOver) return true;

                    if (!isAiMove && this.turn === AI_PLAYER) {
                         this.requestAIMove();
                    }

                    return true;
                }
                this.selected = null;
                this.render();
                await this.updateHighlights();
                return false;
            }

            executeMove(from, to) {
                const f = toCoords(from);
                const t = toCoords(to);
                const p = this.board[f.row][f.col];
                const pType = PIECE_MAP[p].type;
                const color = PIECE_MAP[p].color;
                
                // En Passant Capture
                if (pType === 'Pawn' && to === this.enPassant && f.col !== t.col && !this.board[t.row][t.col]) {
                    const r = color === 'w' ? t.row + 1 : t.row - 1;
                    this.board[r][t.col] = '';
                }

                this.enPassant = null;
                // Double Push Pawn for En Passant target
                if (pType === 'Pawn' && Math.abs(f.row - t.row) === 2) {
                    const r = color === 'w' ? t.row + 1 : t.row - 1;
                    this.enPassant = toNotation(r, t.col);
                }

                // Castling
                if (pType === 'King' && Math.abs(f.col - t.col) === 2) {
                    const rookRow = f.row;
                    const rookFromCol = t.col > f.col ? 7 : 0;
                    const rookToCol = t.col > f.col ? 5 : 3;
                    this.board[rookRow][rookToCol] = this.board[rookRow][rookFromCol];
                    this.board[rookRow][rookFromCol] = '';
                }

                // Castling Rights Update
                if (pType === 'King') { this.castling[color+'K']=false; this.castling[color+'Q']=false; }
                if (from==='a1'||to==='a1') this.castling.wQ = false;
                if (from==='h1'||to==='h1') this.castling.wK = false;
                if (from==='a8'||to==='a8') this.castling.bQ = false;
                if (from==='h8'||to==='h8') this.castling.bK = false;

                this.board[t.row][t.col] = p;
                this.board[f.row][f.col] = '';

                // Promotion
                if (this.isPawnPromotion(from, to)) {
                    if (this.pendingPromo && this.pendingPromo.type) {
                        const promoCode = color === 'w' ? this.pendingPromo.type : this.pendingPromo.type.toLowerCase();
                        this.board[t.row][t.col] = promoCode;
                        this.pendingPromo = null;
                    } 
                }

                this.lastMove = {from, to};
                this.switchTurn();
            }

            switchTurn() {
                this.turn = this.turn === 'w' ? 'b' : 'w';
                this.checkGameOver(); 
            }
            
            async checkGameOver() {
                if (!sfReady) return; // Cannot check game over state without Stockfish

                const { moves, inCheck } = await this.getLegalMoves(null);
                
                this.inCheck = inCheck; 
                
                if (moves.length === 0) {
                    this.isGameOver = true;

                    if (this.inCheck) {
                        gameOverMessage.textContent = `${this.turn === 'w' ? 'Black' : 'White'} wins by Checkmate!`;
                    } else {
                        gameOverMessage.textContent = 'Stalemate!';
                    }
                    gameOverDialog.style.display = 'block';
                }
            }


            // --- Move Input Handling ---
            async onMouseDown(e, notation) { 
                if (this.isAnimating || this.isGameOver || this.turn === AI_PLAYER || !sfReady) return;
                
                const { row, col } = toCoords(notation);
                const piece = this.board[row][col];
                const pieceColor = piece ? PIECE_MAP[piece].color : null;
                
                const previousSelection = this.selected;

                if (previousSelection) {
                    const moveSucceeded = await this.tryMove(previousSelection, notation); 
                    if (moveSucceeded) return; 
                }
                
                if (piece && pieceColor === this.turn) {
                    this.selected = notation;
                } else {
                    this.selected = null; 
                }
                
                this.render(); 
                await this.updateHighlights(); 
            }
            
            onMouseMove(e) {
                // Dragging logic (Skipped)
            }
            onMouseUp(e) {
                // Dropping logic (Skipped)
            }


            // --- VALIDATION METHODS (Uses Stockfish) ---
            
            isPawnPromotion(from, to) {
                const f = toCoords(from);
                const t = toCoords(to);
                const p = this.board[f.row][f.col];
                if (!p || PIECE_MAP[p].type !== 'Pawn') return false;
                const targetRank = PIECE_MAP[p].color === 'w' ? 0 : 7;
                return t.row === targetRank;
            }
            
            async getLegalMoves(pos = null) {
                if (!sfReady) return { moves: [], inCheck: false };

                const movePromise = new Promise((resolve) => {
                    pendingLegalMovesRequest = { resolve: resolve, checkStatusLine: null };
                });

                const currentFEN = this.getFEN(this.board, this.turn, this.castling, this.enPassant);
                stockfish.postMessage("stop"); 
                stockfish.postMessage(`position fen ${currentFEN}`);
                stockfish.postMessage("d"); 

                const { moves, inCheck } = await movePromise;

                if (!pos) {
                    return { moves, inCheck };
                } else {
                    return { moves: moves.filter(move => move.startsWith(pos)), inCheck };
                }
            }
            
            showPromo() {
                const color = this.turn;
                promoChoices.innerHTML = '';
                const pieces = ['Q', 'R', 'B', 'N'];
                pieces.forEach(p => {
                    const pCode = color === 'w' ? p : p.toLowerCase();
                    const div = document.createElement('div');
                    div.className = `piece-choice piece ${PIECE_MAP[pCode].class}`;
                    div.onclick = () => {
                        this.pendingPromo.type = p;
                        promoDialog.style.display = 'none';
                        this.tryMove(this.pendingPromo.from, this.pendingPromo.to);
                    };
                    promoChoices.appendChild(div);
                });
                promoDialog.style.display = 'block';
            }

            updateOpeningDisplay() {
                const currentFENPrefix = this.fenHistory[this.fenHistory.length - 1].split(' ').slice(0, 4).join(' ');
                let openingName = "Game in Progress";
                
                if (this.fenHistory.length <= 5) {
                    for (const [fen, name] of Object.entries(OPENING_DB)) {
                        const dbFENPrefix = fen.split(' ').slice(0, 4).join(' ');
                        if (currentFENPrefix.startsWith(dbFENPrefix)) {
                            openingName = name;
                            break;
                        }
                    }
                }
                
                openingDisplayEl.textContent = openingName;
            }
        }

        const game = new ChessGame();
        
    </script>
</body>
</html>
