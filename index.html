<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI Coach - Analytical Layout</title>
    <style>
        /* --- GENERAL LAYOUT --- */
        body {
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 20px 0;
            margin: 0;
            background-color: #f0f0f0;
            user-select: none;
            font-family: sans-serif;
        }

        /* --- CONTROL PANEL --- */
        #control-panel {
            width: 800px; /* Kept wide for centered look */
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #control-panel label {
            font-weight: bold;
            color: #333;
        }

        #control-panel select, #control-panel button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1em;
            cursor: pointer;
        }
        
        #reset-button {
            background-color: #f44336;
            color: white;
            border: none;
            font-weight: bold;
        }

        /* --- MAIN GAME CONTAINER: CSS GRID DEFINITIVE FIX --- */
        #game-container {
            /* Now using CSS Grid to enforce 3 columns */
            display: grid; 
            /* Columns: Board, Gap, Eval Bar, Gap, Sidebar */
            grid-template-columns: 480px 20px 30px 20px 260px;
            grid-template-rows: auto;
            align-items: start; 
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            width: auto; /* Let grid columns define total width */
        }
        
        /* Apply Grid Column positioning explicitly in the HTML structure: 
           Board is 1st column, Bar is 3rd, Sidebar is 5th.
           Gaps are columns 2 and 4.
        */
        #chessboard { grid-column: 1; }
        #evaluation-bar-container { grid-column: 3; }
        #sidebar { grid-column: 5; }


        /* --- CHESS BOARD (Resized) --- */
        .square-size {
            width: 60px; 
            height: 60px; 
        }
        
        #chessboard {
            width: 480px; /* 8 * 60px */
            height: 480px; /* 8 * 60px */
            display: grid;
            grid-template-columns: repeat(8, 60px); 
            grid-template-rows: repeat(8, 60px);
            border: 5px solid #333;
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
            background-color: #333;
            position: relative; 
        }

        .square {
            box-sizing: border-box; 
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; 
        }

        .light { background-color: #eed6b0; }
        .dark { background-color: #b58863; }
        
        .piece {
            width: 100%;
            height: 100%;
            background-size: 85%;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            z-index: 2;
        }
        
        /* Piece moving animation style */
        .moving-piece {
            transition: transform 0.3s ease-out;
            z-index: 1000;
        }
        
        .dragging {
            width: 60px; 
            height: 60px; 
            transform: scale(1.15); 
        }

        /* --- EVALUATION BAR STYLES --- */
        #evaluation-bar-container {
            width: 30px; 
            height: 480px; /* Matches board height (8 * 60px) */
            background-color: #000; /* Black's color */
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        #evaluation-bar-fill {
            position: absolute;
            bottom: 0; 
            width: 100%;
            background-color: #fff; /* White's color */
            transition: height 0.3s ease-out;
        }
        
        #evaluation-score {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            white-space: nowrap;
            font-weight: bold;
            font-size: 1.1em;
            color: #fff; /* Score text color */
            z-index: 5;
            transition: transform 0.3s ease-out;
        }
        
        /* --- SIDEBAR AND HISTORY --- */
        #sidebar {
            width: 260px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-box {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        #opening-display {
            font-size: 1.1em;
            font-weight: bold;
            color: #007bff;
        }

        #move-list-container {
            max-height: 400px; 
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
        }
        
        #move-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px 10px; 
        }

        #move-list li {
            font-size: 0.9em;
            padding: 2px 5px;
            border-radius: 3px;
            flex-basis: 45%; 
            display: flex;
        }
        
        .move-number {
            font-weight: bold;
            color: #666;
            margin-right: 5px;
        }
        
        /* --- PIECE IMAGES AND HIGHLIGHTS (rest of your CSS remains the same) --- */
        .wk { background-image: url('images/wk.png'); }
        .wq { background-image: url('images/wq.png'); }
        .wr { background-image: url('images/wr.png'); }
        .wb { background-image: url('images/wb.png'); }
        .wn { background-image: url('images/wn.png'); }
        .wp { background-image: url('images/wp.png'); }
        .bk { background-image: url('images/bk.png'); }
        .bq { background-image: url('images/bq.png'); }
        .br { background-image: url('images/br.png'); }
        .bb { background-image: url('images/bb.png'); }
        .bn { background-image: url('images/bn.png'); }
        .bp { background-image: url('images/bp.png'); }

        .promo-Q { background-image: url('images/wq.png'); }
        .promo-R { background-image: url('images/wr.png'); }
        .promo-B { background-image: url('images/wb.png'); }
        .promo-N { background-image: url('images/wn.png'); }
        
        .selected { background-color: rgba(255, 255, 0, 0.5) !important; }
        .in-check { background-color: rgba(255, 0, 0, 0.6) !important; }

        .move-target::after {
            content: '';
            display: block;
            width: 18px; 
            height: 18px; 
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .square.move-target:not(:empty)::after { display: none; }
        .square.move-target .piece {
             box-shadow: inset 0 0 0 4px rgba(0, 0, 0, 0.2); 
             border-radius: 50%;
        }

        /* --- DIALOGS (Z-index ensures these are always on top) --- */
        .piece-choice {
            width: 45px;
            height: 45px;
        }
        .overlay-dialog {
            position: fixed; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            z-index: 10000;
            display: none;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="control-panel">
        <div>
            <label for="color-selector">Play As:</label>
            <select id="color-selector" onchange="game.setPlayerColor(this.value)">
                <option value="w" selected>White</option>
                <option value="b">Black</option>
                <option value="r">Random</option>
            </select>
        </div>
        
        <div>
            <label for="elo-selector">AI ELO Rating:</label>
            <select id="elo-selector" onchange="game.setDifficulty(this.value)">
                <option value="250">250 (Beginner)</option>
                <option value="500">500 (Novice)</option>
                <option value="800">800 (Casual)</option>
                <option value="1100">1100 (Intermediate)</option>
                <option value="1400">1400 (Club Player)</option>
                <option value="1700">1700 (Expert)</option>
                <option value="2000">2000 (Master)</option>
                <option value="2200">2200 (Candidate Master)</option>
                <option value="2300">2300 (FIDE Master)</option>
                <option value="2400">2400 (International Master)</option>
                <option value="2500">2500 (Grandmaster)</option>
                <option value="2700" selected>2700 (Super GM - Default)</option>
            </select>
        </div>
        
        <button id="reset-button" onclick="game.restartGame()">ðŸ”¥ Reset Game</button>
    </div>
    
    <div id="promotion-dialog" class="overlay-dialog">
        <h3>Promote to:</h3>
        <div id="promotion-choices"></div>
    </div>
    
    <div id="game-over-dialog" class="overlay-dialog">
        <h3 id="game-over-message"></h3>
        <button onclick="game.restartGame()">Restart Game</button>
    </div>

    <div id="game-container">
        
        <div id="chessboard" class="square-size"></div>

        <div id="evaluation-bar-container">
            <div id="evaluation-bar-fill"></div>
            <div id="evaluation-score">0.00</div>
        </div>
        
        <div id="sidebar">
            
            <div class="info-box">
                <h4>Opening:</h4>
                <div id="opening-display">Initial Position</div>
            </div>

            <div class="info-box">
                <h4>Move History:</h4>
                <div id="move-list-container">
                    <ol id="move-list"></ol>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const ROWS = 8;
        const COLS = 8;
        const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        let AI_PLAYER = 'b'; 

        // --- Simplified Opening Database ---
        const OPENING_DB = {
            'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1': 'Open Game (1. e4)',
            'rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq - 0 1': 'Closed Game (1. d4)',
            'rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b KQkq - 0 1': 'English Opening (1. c4)',
            'r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 3': 'Ruy Lopez (Spanish Game)',
            'r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 3': 'Italian Game',
            'rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2': 'Sicilian Defense',
            'rnbqkbnr/ppp2ppp/4p3/3p4/2PP4/8/PP2PPPP/RNBQKBNR w KQkq - 0 3': "Queen's Gambit Declined",
        };


        // --- STOCKFISH ELO MAPPING ---
        const ELO_MAP = {
            '250':  { skill: 0, depth: 1, mistake: 0.95 },
            '500':  { skill: 3, depth: 2, mistake: 0.8 },
            '800':  { skill: 6, depth: 3, mistake: 0.6 },
            '1100': { skill: 9, depth: 5, mistake: 0.4 },
            '1400': { skill: 12, depth: 8, mistake: 0.2 },
            '1700': { skill: 15, depth: 10, mistake: 0.05 },
            '2000': { skill: 18, depth: 12, mistake: 0.0 },
            '2200': { skill: 18, depth: 13, mistake: 0.0 }, 
            '2300': { skill: 19, depth: 14, mistake: 0.0 }, 
            '2400': { skill: 20, depth: 15, mistake: 0.0 }, 
            '2500': { skill: 18, depth: 15, mistake: 0.0 }, 
            '2700': { skill: 20, depth: 18, mistake: 0.0 } 
        };

        // --- DOM ELEMENTS ---
        const boardEl = document.getElementById('chessboard');
        const promoDialog = document.getElementById('promotion-dialog');
        const promoChoices = document.getElementById('promotion-choices');
        const gameOverDialog = document.getElementById('game-over-dialog');
        const gameOverMessage = document.getElementById('game-over-message');
        const eloSelector = document.getElementById('elo-selector');
        const colorSelector = document.getElementById('color-selector');
        const moveListEl = document.getElementById('move-list');
        const openingDisplayEl = document.getElementById('opening-display');
        
        // Evaluation Bar Elements
        const evalFillEl = document.getElementById('evaluation-bar-fill');
        const evalScoreEl = document.getElementById('evaluation-score');


        // --- STOCKFISH WORKER ---
        let stockfish = null;
        let sfReady = false;
        const BEST_MOVES = []; 
        let currentAISettings = ELO_MAP['2700']; 
        let userSelectedColor = 'w'; 

        function initStockfish() {
            try {
                stockfish = new Worker("stockfish.js"); 
                
                stockfish.onmessage = handleStockfishMessage;
                stockfish.onerror = (e) => {
                    console.error("Stockfish worker error:", e);
                    alert("Stockfish AI failed to load. Ensure 'stockfish.js' is accessible via your web server (e.g., GitHub Pages).");
                };

                stockfish.postMessage("uci");
                stockfish.postMessage("isready");

                console.log("Stockfish worker initiated.");
            } catch (e) {
                console.error("Failed to load stockfish.js:", e);
                alert("Stockfish AI failed to load. Ensure 'stockfish.js' is accessible via your web server (e.g., GitHub Pages).");
            }
        }

        function configureStockfish() {
            if (!stockfish || !sfReady) return;
            stockfish.postMessage(`setoption name Skill Level value ${currentAISettings.skill}`);
            console.log(`Stockfish configured: Skill Level ${currentAISettings.skill}, Depth ${currentAISettings.depth}`);
        }

        function handleStockfishMessage(event) {
            const line = event.data;

            if (line === "readyok") {
                sfReady = true;
                configureStockfish();
                if (game.turn === AI_PLAYER) game.requestAIMove();
                
                game.requestLiveEvaluation();
            }

            if (line.startsWith("info depth") || line.startsWith("bestmove")) {
                const parts = line.split(' ');
                
                // --- EVALUATION BAR UPDATE ---
                const scoreIndex = parts.indexOf("score");
                if (scoreIndex !== -1) {
                    const scoreType = parts[scoreIndex + 1];
                    const scoreValue = parseInt(parts[scoreIndex + 2]);
                    
                    if (scoreType === 'cp') {
                        game.updateEvaluationDisplay(scoreValue / 100, 'cp');
                    } else if (scoreType === 'mate') {
                        game.updateEvaluationDisplay(scoreValue, 'mate');
                    }
                }
                // -----------------------------
                
                if (line.startsWith("info depth")) {
                    const depthIndex = parts.indexOf("depth");
                    const depth = depthIndex !== -1 ? parseInt(parts[depthIndex + 1]) : -1;
                    
                    if (depth > 10 || currentAISettings.skill < 15) {
                        const moveIndex = parts.indexOf("pv");
                        
                        if (scoreIndex !== -1 && moveIndex !== -1) {
                            const move = parts[moveIndex + 1];

                            if (!BEST_MOVES.some(m => m.move === move)) {
                                BEST_MOVES.push({
                                    move: move,
                                    score: scoreValue,
                                    type: parts[scoreIndex + 1]
                                });
                                BEST_MOVES.sort((a, b) => b.score - a.score).splice(3);
                            }
                        }
                    }
                } else if (line.startsWith("bestmove") && BEST_MOVES.length > 0) {
                    game.processAIMove();
                    game.requestLiveEvaluation(); 
                }
            }
        }
        
        // --- CHESS LOGIC UTILITIES ---
        
        const PIECE_MAP = {
            'K': { class: 'wk', type: 'King', color: 'w' }, 'Q': { class: 'wq', type: 'Queen', color: 'w' },
            'R': { class: 'wr', type: 'Rook', color: 'w' }, 'B': { class: 'wb', type: 'Bishop', color: 'w' },
            'N': { class: 'wn', type: 'Knight', color: 'w' }, 'P': { class: 'wp', type: 'Pawn', color: 'w' },
            'k': { class: 'bk', type: 'King', color: 'b' }, 'q': { class: 'bq', type: 'Queen', color: 'b' },
            'r': { class: 'br', type: 'Rook', color: 'b' }, 'b': { class: 'bb', type: 'Bishop', color: 'b' },
            'n': { class: 'bn', type: 'Knight', color: 'b' }, 'p': { class: 'bp', type: 'Pawn', color: 'b' },
            '': { class: '', type: 'Empty', color: '' }
        };

        function toCoords(notation) {
            const col = notation.charCodeAt(0) - 97;
            const row = 8 - parseInt(notation[1]);
            return { row, col };
        }
        function toNotation(row, col) {
            return String.fromCharCode(97 + col) + (8 - row);
        }
        
        class ChessGame {
            constructor() {
                document.addEventListener('mousemove', e => this.onMouseMove(e));
                document.addEventListener('mouseup', e => this.onMouseUp(e));
                
                this.setDifficulty(eloSelector.value);
                this.moveHistory = []; 
                this.setPlayerColor(colorSelector.value); 
            }
            
            setDifficulty(elo) {
                currentAISettings = ELO_MAP[elo];
                configureStockfish(); 
            }

            setPlayerColor(colorCode) {
                userSelectedColor = colorCode;
                
                if (colorCode === 'r') {
                    const randomColor = Math.random() < 0.5 ? 'w' : 'b';
                    AI_PLAYER = randomColor === 'w' ? 'b' : 'w';
                } else {
                    AI_PLAYER = colorCode === 'w' ? 'b' : 'w';
                }
                
                this.initBoard(); 
            }

            initBoard() {
                this.board = Array(ROWS).fill(null).map(() => Array(COLS).fill('')); 
                this.turn = 'w';
                this.castling = { wK: true, wQ: true, bK: true, bQ: true };
                this.enPassant = null;
                this.selected = null; 
                this.pendingPromo = null;
                this.inCheck = false;
                this.dragOrigin = null;
                this.dragGhost = null;
                this.isDragging = false;
                this.isAnimating = false;
                this.isGameOver = false;
                this.moveHistory = []; 

                this.loadFEN(START_FEN);
                gameOverDialog.style.display = 'none';
                this.updateMoveListDisplay();
                this.updateOpeningDisplay();
                this.render(); 

                if (sfReady) {
                    if (this.turn === AI_PLAYER) this.requestAIMove();
                    this.requestLiveEvaluation();
                }
            }

            restartGame() {
                this.initBoard();
                this.render();
            }

            getFEN() {
                let fen = "";
                for (let r = 0; r < 8; r++) {
                    let emptyCount = 0;
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece) {
                            if (emptyCount > 0) {
                                fen += emptyCount;
                                emptyCount = 0;
                            }
                            fen += piece;
                        } else {
                            emptyCount++;
                        }
                    }
                    if (emptyCount > 0) fen += emptyCount;
                    if (r < 7) fen += "/";
                }
                
                let fullFen = `${fen} ${this.turn}`;
                let castlingStr = "";
                if (this.castling.wK) castlingStr += "K";
                if (this.castling.wQ) castlingStr += "Q";
                if (this.castling.bK) castlingStr += "k";
                if (this.castling.bQ) castlingStr += "q";
                fullFen += ` ${castlingStr || '-'}`;
                fullFen += ` ${this.enPassant || '-'}`;
                fullFen += ` 0 1`; 

                return fullFen;
            }

            loadFEN(fen) {
                const parts = fen.split(' ');
                let r = 0, c = 0;
                for (const char of parts[0]) {
                    if (char === '/') { r++; c = 0; } 
                    else if (/\d/.test(char)) { c += parseInt(char); } 
                    else { this.board[r][c] = char; c++; }
                }
                this.turn = parts[1];
                this.updateCheckState();
            }

            // --- History and Analysis Updates ---
            recordMove(uciMove) {
                this.moveHistory.push(uciMove);
                this.updateMoveListDisplay();
                this.updateOpeningDisplay();
                this.requestLiveEvaluation();
            }

            updateMoveListDisplay() {
                moveListEl.innerHTML = '';
                let whiteMove = '';
                let moveNumber = 1;

                for (let i = 0; i < this.moveHistory.length; i++) {
                    const uci = this.moveHistory[i];
                    
                    if (i % 2 === 0) { 
                        if (whiteMove) { 
                            let li = document.createElement('li');
                            li.innerHTML = `<span class="move-number">${moveNumber}.</span> ${whiteMove}`;
                            moveListEl.appendChild(li);
                            moveNumber++;
                        }
                        whiteMove = uci;
                    } else { 
                        let li = document.createElement('li');
                        li.innerHTML = `<span class="move-number">${moveNumber}.</span> ${whiteMove} ${uci}`;
                        moveListEl.appendChild(li);
                        whiteMove = '';
                        moveNumber++;
                    }
                }
                
                if (whiteMove) {
                    let li = document.createElement('li');
                    li.innerHTML = `<span class="move-number">${moveNumber}.</span> ${whiteMove}`;
                    moveListEl.appendChild(li);
                }
                
                moveListEl.parentElement.scrollTop = moveListEl.parentElement.scrollHeight;
            }

            updateOpeningDisplay() {
                const fullFen = this.getFEN();
                const checkFen = fullFen.split(' ').slice(0, 4).join(' ');
                
                let openingName = 'Game in Progress...';
                
                for (const fenKey in OPENING_DB) {
                    if (checkFen.startsWith(fenKey.split(' ').slice(0, 4).join(' '))) {
                        openingName = OPENING_DB[fenKey];
                        break;
                    }
                }
                
                if (fullFen.startsWith(START_FEN.split(' ').slice(0,4).join(' '))) {
                    openingName = 'Initial Position';
                }

                openingDisplayEl.textContent = openingName;
            }

            render() {
                if (this.isAnimating) return; 

                boardEl.innerHTML = '';
                const enableInput = this.turn !== AI_PLAYER && !this.isGameOver;
                const squareSizeClass = 'square-size'; 

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const sq = document.createElement('div');
                        const notation = toNotation(r, c);
                        sq.id = notation;
                        sq.className = `square ${squareSizeClass} ${(r + c) % 2 ? 'dark' : 'light'}`;
                        
                        if (enableInput) {
                            sq.addEventListener('mousedown', e => this.onMouseDown(e, notation));
                        }

                        const pCode = this.board[r][c];
                        if (pCode) {
                            const pDiv = document.createElement('div');
                            pDiv.className = `piece ${PIECE_MAP[pCode].class}`;
                            sq.appendChild(pDiv);
                        }
                        
                        if (this.selected === notation) sq.classList.add('selected');
                        
                        if (this.inCheck && pCode && PIECE_MAP[pCode].type === 'King' && PIECE_MAP[pCode].color === this.turn) {
                            sq.classList.add('in-check');
                        }

                        boardEl.appendChild(sq);
                    }
                }
                
                if (this.selected) {
                    this.getLegalMoves(this.selected).forEach(m => {
                        document.getElementById(m)?.classList.add('move-target');
                    });
                }
            }
            
            // --- EVALUATION BAR LOGIC ---
            updateEvaluationDisplay(score, type) {
                if (!sfReady) return;
                
                let percent;
                let scoreText;

                if (type === 'mate') {
                    // Mate is extreme, set max percentage
                    percent = score > 0 ? 100 : 0;
                    scoreText = `M${Math.abs(score)}`;
                } else {
                    // Normalize centipawn score: use tanh for smooth scaling
                    // Max centipawn value is capped for visualization (e.g., 1000cp = 10 pawns)
                    const maxCp = 1000;
                    const normalizedScore = Math.min(Math.max(score, -maxCp), maxCp) / maxCp;
                    
                    // Convert to percentage (0% for Black advantage, 100% for White advantage)
                    percent = 50 + (50 * normalizedScore);
                    
                    // Format score string
                    const sign = score > 0 ? '+' : '';
                    scoreText = `${sign}${score.toFixed(2)}`;
                }

                evalFillEl.style.height = `${percent}%`;
                evalScoreEl.textContent = scoreText;
                
                // Change score text color based on who has the advantage
                if (percent < 40) {
                    evalScoreEl.style.color = '#fff'; // Black advantage (dark background)
                    evalFillEl.style.backgroundColor = '#000';
                } else if (percent > 60) {
                    evalScoreEl.style.color = '#000'; // White advantage (light background)
                    evalFillEl.style.backgroundColor = '#fff';
                } else {
                    evalScoreEl.style.color = '#333'; // Neutral
                    evalFillEl.style.backgroundColor = '#fff';
                }
            }

            requestLiveEvaluation() {
                if (this.isAnimating || !sfReady || this.isGameOver) return;
                
                stockfish.postMessage("stop");
                const currentFEN = this.getFEN();
                
                stockfish.postMessage(`position fen ${currentFEN}`);
                stockfish.postMessage("go depth 15");
            }
            // ---------------------------------


            requestAIMove() {
                if (this.isGameOver || this.turn !== AI_PLAYER || !sfReady || this.isAnimating) return;
                
                stockfish.postMessage("stop"); 
                BEST_MOVES.length = 0;

                const currentFEN = this.getFEN();
                stockfish.postMessage(`position fen ${currentFEN}`);
                stockfish.postMessage(`go depth ${currentAISettings.depth}`);
                
                console.log(`AI (${this.turn === 'w' ? 'White' : 'Black'}) is thinking at depth ${currentAISettings.depth}...`);
            }

            processAIMove() {
                if (BEST_MOVES.length === 0) {
                    console.error("Stockfish returned no moves!");
                    this.switchTurn();
                    return;
                }

                BEST_MOVES.sort((a, b) => b.score - a.score);

                let moveUCI;
                
                if (Math.random() < currentAISettings.mistake) {
                    const mistakeIndex = Math.floor(Math.random() * (BEST_MOVES.length > 1 ? BEST_MOVES.length : 1));
                    moveUCI = BEST_MOVES[mistakeIndex].move;
                    console.log(`AI made a mistake! Chose candidate ${mistakeIndex + 1}: ${moveUCI}`);
                } else {
                    moveUCI = BEST_MOVES[0].move;
                    console.log(`AI chose best move: ${moveUCI}`);
                }
                
                const from = moveUCI.substring(0, 2);
                const to = moveUCI.substring(2, 4);
                const promotion = moveUCI.length === 5 ? moveUCI.substring(4, 5) : null;
                
                if (promotion) {
                    this.pendingPromo = { to, type: promotion.toUpperCase() };
                }

                this.tryMove(from, to, true);
            }

            checkGameOver() {
                let hasMoves = false;
                for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
                    const p = this.board[r][c];
                    if(p && PIECE_MAP[p].color === this.turn) {
                        if(this.getLegalMoves(toNotation(r,c)).length > 0) hasMoves = true;
                    }
                }

                if (!hasMoves) {
                    this.isGameOver = true;
                    stockfish.postMessage("stop");
                    
                    if (this.inCheck) {
                        const winner = this.turn === 'w' ? 'Black' : 'White';
                        gameOverMessage.textContent = `Checkmate! ${winner} Wins! ðŸ‘‘`;
                    } else {
                        gameOverMessage.textContent = "Stalemate! Game is a Draw.";
                    }
                    gameOverDialog.style.display = 'block';
                }
            }
            
            async animateMove(from, to) {
                const fromEl = document.getElementById(from);
                const toEl = document.getElementById(to);
                const pieceEl = fromEl?.querySelector('.piece'); 
                
                if (!pieceEl) return;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const offset = (80 - 60) / 2; 
                const deltaX = toRect.left - fromRect.left + offset;
                const deltaY = toRect.top - fromRect.top + offset;

                toEl.innerHTML = '';
                pieceEl.classList.add('moving-piece');
                pieceEl.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

                return new Promise(resolve => {
                    pieceEl.addEventListener('transitionend', () => {
                         pieceEl.classList.remove('moving-piece');
                         pieceEl.style.transform = '';
                         resolve();
                    }, { once: true });
                    setTimeout(() => {
                         pieceEl.classList.remove('moving-piece');
                         pieceEl.style.transform = '';
                         resolve();
                    }, 300);
                });
            }

            async tryMove(from, to, isAiMove = false) {
                if (this.isGameOver || this.isAnimating) return false;
                
                let uciMove = from + to; 
                
                if (this.isMoveLegal(from, to)) {
                    this.isAnimating = true;
                    this.selected = null; 
                    
                    if (this.isPawnPromotion(from, to)) {
                        if (isAiMove) {
                             uciMove += (this.pendingPromo.type.toLowerCase() || 'q'); 
                        } else if (!this.pendingPromo) {
                            this.pendingPromo = { from, to, uci: uciMove };
                            this.showPromo();
                            this.isAnimating = false; 
                            return true; 
                        }
                    }

                    await this.animateMove(from, to);
                    
                    this.executeMove(from, to);
                    this.isAnimating = false;
                    
                    if (!this.isPawnPromotion(from, to) || isAiMove || this.pendingPromo === null) {
                         this.recordMove(uciMove);
                    }


                    this.render();

                    if (this.isGameOver) return true;

                    if (!isAiMove && this.turn === AI_PLAYER) {
                         this.requestAIMove();
                    }

                    return true;
                }
                this.selected = null;
                this.render();
                return false;
            }

            isPawnPromotion(from, to) {
                const f = toCoords(from);
                const p = this.board[f.row][f.col];
                const t = toCoords(to);

                return PIECE_MAP[p].type === 'Pawn' && (t.row === 0 || t.row === 7);
            }
            
            executeMove(from, to) {
                const f = toCoords(from);
                const t = toCoords(to);
                const p = this.board[f.row][f.col];
                const pType = PIECE_MAP[p].type;
                
                if (pType === 'Pawn' && to === this.enPassant) {
                    const r = this.turn === 'w' ? t.row + 1 : t.row - 1;
                    this.board[r][t.col] = '';
                }

                this.enPassant = null;
                if (pType === 'Pawn' && Math.abs(f.row - t.row) === 2) {
                    const r = this.turn === 'w' ? t.row + 1 : t.row - 1;
                    this.enPassant = toNotation(r, t.col);
                }

                if (pType === 'King' && Math.abs(f.col - t.col) === 2) {
                    const side = t.col > f.col ? 'K' : 'Q';
                    const rFrom = side === 'K' ? 7 : 0;
                    const rTo = side === 'K' ? 5 : 3;
                    this.board[f.row][rTo] = this.board[f.row][rFrom];
                    this.board[f.row][rFrom] = '';
                }

                if (pType === 'King') { this.castling[this.turn+'K']=false; this.castling[this.turn+'Q']=false; }
                if (from==='a1'||to==='a1') this.castling.wQ = false;
                if (from==='h1'||to==='h1') this.castling.wK = false;
                if (from==='a8'||to==='a8') this.castling.bQ = false;
                if (from==='h8'||to==='h8') this.castling.bK = false;

                this.board[t.row][t.col] = p;
                this.board[f.row][f.col] = '';

                if (this.isPawnPromotion(from, to)) {
                    if (this.pendingPromo && this.pendingPromo.type) {
                        const promoCode = this.turn === 'w' ? this.pendingPromo.type : this.pendingPromo.type.toLowerCase();
                        this.board[t.row][t.col] = promoCode;
                        this.pendingPromo = null;
                    } 
                }

                this.switchTurn();
            }

            switchTurn() {
                this.turn = this.turn === 'w' ? 'b' : 'w';
                this.updateCheckState();
                this.checkGameOver();
            }
            
            showPromo() {
                promoChoices.innerHTML = '';
                const c = this.turn;
                const promoSuffix = c === 'w' ? '' : 'b'; 
                
                ['Q','R','B','N'].forEach(type => {
                    const div = document.createElement('div');
                    div.className = `piece-choice promo-${type}`;
                    div.style.backgroundImage = `url('images/${promoSuffix}${type.toLowerCase()}.png')`; 

                    div.onclick = () => {
                        const { from, to, uci } = this.pendingPromo;
                        const t = toCoords(to);
                        
                        const promoCode = c === 'w' ? type : type.toLowerCase();
                        this.board[t.row][t.col] = promoCode;
                        
                        promoDialog.style.display = 'none';
                        this.pendingPromo = null;
                        
                        this.recordMove(uci + type.toLowerCase()); 
                        
                        this.switchTurn();
                        this.render();
                    };
                    promoChoices.appendChild(div);
                });
                promoDialog.style.display = 'block';
            }
            
            updateCheckState() { this.inCheck = this.isKingInCheck(this.turn); }

            onMouseDown(e, notation) {
                e.preventDefault();
                if (this.pendingPromo || this.isAnimating || this.isGameOver || this.turn === AI_PLAYER) return;

                const { row, col } = toCoords(notation);
                const p = this.board[row][col];
                
                if (p && PIECE_MAP[p].color === this.turn) {
                    this.dragOrigin = notation;
                    this.isDragging = false;
                } else if (this.selected) {
                    this.tryMove(this.selected, notation);
                    this.dragOrigin = null;
                }
            }

            onMouseMove(e) {
                if (!this.dragOrigin) return;

                if (!this.isDragging) {
                    this.isDragging = true;
                    this.createGhost(e);
                    
                    if (this.selected !== this.dragOrigin) {
                        this.selected = this.dragOrigin;
                        this.render();
                    } 
                    const originEl = document.getElementById(this.dragOrigin)?.querySelector('.piece');
                    if(originEl) originEl.style.opacity = '0.2'; 
                }

                if (this.dragGhost) {
                    this.dragGhost.style.left = (e.clientX - 30) + 'px'; 
                    this.dragGhost.style.top = (e.clientY - 30) + 'px'; 
                }
            }

            onMouseUp(e) {
                if (!this.dragOrigin || this.isAnimating) return;

                const originEl = document.getElementById(this.dragOrigin)?.querySelector('.piece');
                if(originEl) originEl.style.opacity = '1';

                if (this.isDragging) {
                    this.removeGhost();
                    const targetEl = document.elementFromPoint(e.clientX, e.clientY);
                    const sq = targetEl?.closest('.square');
                    
                    if (sq) {
                        this.tryMove(this.dragOrigin, sq.id);
                    } else {
                        this.render();
                    }
                } else {
                    if (this.selected === this.dragOrigin) this.selected = null;
                    else this.selected = this.dragOrigin;
                    this.render();
                }

                this.dragOrigin = null;
                this.isDragging = false;
            }

            createGhost(e) {
                const srcEl = document.getElementById(this.dragOrigin)?.querySelector('.piece');
                if (!srcEl) return;
                this.dragGhost = srcEl.cloneNode(true);
                this.dragGhost.classList.add('dragging');
                document.body.appendChild(this.dragGhost);
                this.dragGhost.style.left = (e.clientX - 30) + 'px'; 
                this.dragGhost.style.top = (e.clientY - 30) + 'px'; 
            }

            removeGhost() {
                if (this.dragGhost) {
                    this.dragGhost.remove();
                    this.dragGhost = null;
                }
            }
            
            // --- VALIDATION METHODS ---

            isMoveLegal(from, to) {
                const f = toCoords(from);
                const t = toCoords(to);
                const p = this.board[f.row][f.col];
                const target = this.board[t.row][t.col];

                if (!p) return false;
                const pData = PIECE_MAP[p];
                const tData = PIECE_MAP[target] || { color: '' };

                if (pData.color !== this.turn || pData.color === tData.color) return false;

                let valid = false;
                const dy = t.row - f.row;
                const dx = t.col - f.col;
                const ady = Math.abs(dy);
                const adx = Math.abs(dx);

                if (pData.type === 'Pawn') {
                    const dir = pData.color === 'w' ? -1 : 1;
                    const start = pData.color === 'w' ? 6 : 1;
                    if (adx === 0 && !target) {
                        if (dy === dir) valid = true;
                        else if (f.row === start && dy === dir * 2 && !this.board[f.row + dir][f.col]) valid = true;
                    } else if (adx === 1 && dy === dir) {
                        if (target || to === this.enPassant) valid = true;
                    }
                } 
                else if (pData.type === 'Knight') {
                    if ((ady === 2 && adx === 1) || (ady === 1 && adx === 2)) valid = true;
                } 
                else if (pData.type === 'King') {
                    if (ady <= 1 && adx <= 1) valid = true;
                    else if (ady === 0 && adx === 2) valid = this.canCastle(f, t);
                } 
                else {
                    const isDiag = adx === ady;
                    const isLine = adx === 0 || ady === 0;
                    if (pData.type === 'Rook' && isLine || pData.type === 'Bishop' && isDiag || pData.type === 'Queen' && (isDiag||isLine)) {
                        valid = this.isPathClear(f, t);
                    }
                }

                if (!valid) return false;
                return !this.testMoveForCheck(f, t);
            }

            isPathClear(f, t) {
                const dy = Math.sign(t.row - f.row);
                const dx = Math.sign(t.col - f.col);
                let r = f.row + dy, c = f.col + dx;
                while (r !== t.row || c !== t.col) {
                    if (this.board[r][c]) return false;
                    r += dy; c += dx;
                }
                return true;
            }

            canCastle(f, t) {
                if (this.inCheck) return false;
                const side = t.col > f.col ? 'K' : 'Q';
                if (!this.castling[this.turn + side]) return false;
                const dir = Math.sign(t.col - f.col);
                for (let c = f.col + dir; c !== t.col + dir; c += dir) {
                   if (this.isSquareAttacked(f.row, c, this.turn === 'w' ? 'b' : 'w')) return false;
                   if (c !== t.col && this.board[f.row][c]) return false;
                }
                if(!this.board[f.row][side==='K'?7:0]) return false;
                return true;
            }

            testMoveForCheck(f, t) {
                const p = this.board[f.row][f.col];
                const target = this.board[t.row][t.col];
                let epCap = null;

                this.board[t.row][t.col] = p;
                this.board[f.row][f.col] = '';
                if (PIECE_MAP[p].type === 'Pawn' && toNotation(t.row, t.col) === this.enPassant) {
                    const r = this.turn === 'w' ? t.row + 1 : t.row - 1;
                    epCap = { r, c: t.col, val: this.board[r][t.col] };
                    this.board[r][t.col] = '';
                }

                const result = this.isKingInCheck(this.turn);

                if (epCap) this.board[epCap.r][epCap.c] = epCap.val;
                this.board[f.row][f.col] = p;
                this.board[t.row][t.col] = target;
                return result;
            }

            isKingInCheck(color) {
                let kr, kc;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = this.board[r][c];
                        if (p && PIECE_MAP[p].type === 'King' && PIECE_MAP[p].color === color) {
                            kr = r; kc = c; break;
                        }
                    }
                }
                if (typeof kr === 'undefined') return false; 
                return this.isSquareAttacked(kr, kc, color === 'w' ? 'b' : 'w');
            }

            isSquareAttacked(r, c, attackerColor) {
                for (let tr = 0; tr < 8; tr++) {
                    for (let tc = 0; tc < 8; tc++) {
                        const p = this.board[tr][tc];
                        if (p && PIECE_MAP[p].color === attackerColor) {
                            const pType = PIECE_MAP[p].type;
                            const dy = r - tr;
                            const dx = c - tc;
                            const ady = Math.abs(dy);
                            const adx = Math.abs(dx);
                            
                            if(pType === 'Pawn') {
                                const dir = attackerColor==='w'?-1:1;
                                if(dy === dir && adx === 1) return true;
                            }
                            else if (pType === 'Knight') {
                                if((ady===2&&adx===1)||(ady===1&&adx===2)) return true;
                            }
                            else if (pType === 'King') {
                                if(ady<=1 && adx<=1) return true;
                            }
                            else {
                                const isDiag = adx===ady;
                                const isLine = adx===0 || ady===0;
                                let canHit = false;
                                if(pType === 'Rook' && isLine) canHit=true;
                                if(pType === 'Bishop' && isDiag) canHit=true;
                                if(pType === 'Queen' && (isDiag||isLine)) canHit=true;
                                if(canHit && this.isPathClear({row:tr,col:tc}, {row:r,col:c})) return true;
                            }
                        }
                    }
                }
                return false;
            }

            getLegalMoves(pos) {
                const moves = [];
                for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
                    const target = toNotation(r,c);
                    if(this.isMoveLegal(pos, target)) moves.push(target);
                }
                return moves;
            }
        }

        const game = new ChessGame();
        initStockfish();
    </script>
</body>
</html>
